
大家好，经过了前面几期的铺垫，我们终于要正式进入LangGraph的学习阶段了（已经有人在后台骂我挂羊头卖狗肉了...）。废话不多说，直接上干货。

## 由节点、边和状态组成的网状图

在实际搭建Agent之前，我们非常有必要大概理解一下LangGraph的基本工作原理。

LangGraph之所以叫Graph，就是因为用它搭建的AI Agent的逻辑结构呈现为一种网状结构（与Chain所代表的线性链条结构相对应）。

这个网，是由大量的节点（Nodes），以及连接这些节点的边（Edge）组成的，其中：

- **节点（Node）**：其实就是一些封装了业务逻辑的函数，它对流入其中的信息进行处理，并输出一个结果。
- **边（Edge）**：其实就是一种根据上一个节点的输出，来决定选择哪一个节点作为下一环节的函数。

看起来是不是很简单，熟悉Dify、Coze等低代码workflow编排工具的朋友肯定很容易理解这个网状信息流机制。但在节点和边的基础上，LangGraph引入了一个新的概念，**状态（state）**，使得我们的Agent工作流设计可以变得非常的灵活，强大。

## 什么是状态

根据官方解释，**State是一种可以由Agent的所有节点共同使用的数据结构**，这个听起来很抽象，我换个接地气的讲法。
### 先想想Excel表格

大家应该都用过Excel。当我们用Excel做一些表格，我们可能会：

- 1.设计需要的**表格字段**；
- 2.想办法往每个字段下面的单元格中填入具体的**值**，可能是直接填入，也可能是用一个公式，或者是引用其他sheet中的数据；
- 3.通过**预设的公式**，利用上述每个字段对应的单元格中的值，求出一个最终期望的值。

反过来看，我们使用这个表格的目的是获得一个期望的值，由于这个值是由一个预设的公式所求得，那么我们又需要获得这个公式赖以计算的那些单元格的值，而这些单元格的值，又是被表格的各个字段所定义。
### 用Excel表格来理解LangGraph

那么，如果我们把用LangGraph搭建的AI Agent，看做一个高级的“Excel表格”的话：

其中每个**Node**、**Edge**的作用，就是获取、填写、更新这个“表格”用以计算期望结果的“预设公式”所需要的，不同表头字段下的值。而**State**，其实就是我们对表头字段的定义，同时它也负责储存当前各字段下对应单元格的值。

具体来说，通过**State**，我们能够对**Node的输出结果**进行约束、存放。每当**Node**完成了自己的工作，它就会按事先定好的规则对**State的内容**进行更新。顺序在后的Node，还可以根据已被前序Node更新的状态数据来作为输入信息，来执行自己的功能，然后再次更新State的内容。

等到所有的Node都各司其职完成了自己对State的贡献，LLM就能根据最终的State所提供的上下文，来完成用户给出的指令。

## 总结

再总结一下这个比喻，大家可以仔细体会一下：

- **State（状态）**：就像一个Excel表格的表头字段及其所对应的单元格，它定义了Agent所需要获得的数据维度、类型，并储存这些数据。
- **节点（Node）**：就是用来产生每个单元格的具体值的手段，可以想象成每个单元格里的公式；
- **边（Edge）**：就像是表格中那个用来计算最终期望值的公式中的各个运算符号，它将不同单元格的最终值联系起来，通过一个逻辑来获取一个目标值。

下一期，我会带着大家从一个最简单的Hello World Graph开始，慢慢学习如何使用LangGraph来构建我们的AI Agent。




















